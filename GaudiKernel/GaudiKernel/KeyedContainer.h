// $Id $
#ifndef GAUDIKERNEL_KEYEDCONTAINER_H
#define GAUDIKERNEL_KEYEDCONTAINER_H

// Include files
#include <iterator>
#include <algorithm>

namespace GaudiDict  {
  template <class T> struct KeyedContainerDict;
}

// Framework include files
#include "GaudiKernel/ObjectContainerBase.h"
#include "GaudiKernel/KeyedObjectManager.h"
#include "GaudiKernel/KeyedObject.h"

// Forward declarations
// template <class T, class M> class KeyedContainer;

#ifdef WIN32
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif

/** template class KeyedContainer, KeyedContainer.h
 *
 *  This class represents a container, where the contained objects
 *  are accessed by a key. Such a key can be any class, which is able
 *  to convert to and from a 32-bit (long) integer.
 *
 *  To insert objects into the container, this implementation
 *  determines the key in the following way:
 *  - If the object is already keyed, the object's key is kept
 *    and cannot be modified.
 *  - If the object is NOT keyed, and a key is supplied,
 *    this key is used to register the object in the map and
 *    the same key is given to the object.
 *  - If the object is NOT keyed, and NO key is supplied,
 *    a key is generated by the map implementation and this
 *    key is given to the object.
 *
 *  - It is not possible to insert two objects with the same key
 *    into the same container. This causes an exception.
 *
 *  Access to objects is given two-fold:
 *  - Using iterators. This access is very efficient. The container
 *    however, may not be manipulated: No objects may not be
 *    inserted or removed using iterators.
 *  - Using object keys: This access patterns provides random
 *    access to objects.
 *
 *  The KeyedContainer class uses for further specialization a traits
 *  class. By specializing these traits extra behaviour can be
 *  forced on request for special containers or special keys.
 *
 *
 *  @author   M.Frank CERN/LHCb
 *  @version  1.0
 *
 */
template <class DATATYPE, class MAPPING=Containers::HashMap >
class GAUDI_API KeyedContainer: public ObjectContainerBase
{
  friend struct GaudiDict::KeyedContainerDict<DATATYPE>;

public:
  /// Definition of the contained object type
  typedef DATATYPE                                  contained_type;
  /// Definition of the implementing container type
  typedef MAPPING                                   container_type;

  /** General container specific type definitions.
      The following type definitions are generic to most STL containers
      and are also presented by the KeyedContainer class.
      These forward declarations typically are used by STL algorithms.
  */
  //@{
  /// Definition of the STL sequential access type
  typedef typename std::vector<contained_type*>     seq_type;
  /// Definition of the key type: re-use definition of contained type
  typedef typename contained_type::key_type         key_type;
  /// Sequential access: definition of type stored in sequential container
  typedef typename seq_type::value_type             value_type;
  /// Sequential access: reference type used in sequential container
  typedef typename seq_type::reference              reference;
  /// Sequential access: const reference type used in sequential container
  typedef typename seq_type::const_reference        const_reference;
  /// Sequential access: iterator type used in sequential container
  typedef typename seq_type::iterator               iterator;
  /// Sequential access: const iterator type used in sequential container
  typedef typename seq_type::const_iterator         const_iterator;
  /// Sequential access: reverse iterator type used in sequential container
  typedef typename seq_type::reverse_iterator       reverse_iterator;
  /** Sequential access: const reverse iterator type used in
      sequential container.
  */
  typedef typename seq_type::const_reverse_iterator const_reverse_iterator;
  //@}
private:
  /** Traits class definition. Specializing traits allows to specialize the
   *  container implementation for special needs.
   */
  typedef typename Containers::traits<container_type, contained_type> traits;

  /**@name Implementation helpers.
  */
  //@{
  /// Map container to facilitate object access by key.
  container_type m_cont;
  /// Array to allow sequential access to the object (can be ordered).
  seq_type       m_sequential;
  /// Array to allow random access to objects (not exposed)
  seq_type*      m_random;

  /// Internal function to access objects within the container
#ifdef CHECK_KEYED_CONTAINER
  value_type i_object(const key_type& k) const  {
    if ( 0 == m_cont.isDirect() )  {
      if ( traits::checkBounds(m_random, k) )  {
        value_type p = *(m_random->begin()+traits::hash(k));
        if ( traits::checkKey(p, k) ) {
          return p;
        }
      }
      return 0;
    }
    value_type p = value_type(m_cont.object(traits::hash(k)));
    return traits::checkKey(p, k) ? p : 0;
  }
#else
  FORCE_INLINE value_type i_object(const key_type& k) const  {
    return 0==m_cont.isDirect()
      ? value_type(*(m_random->begin()+traits::hash(k)))
      : value_type(m_cont.object(traits::hash(k)));
  }
#endif
  /// Internal function to erase an object from the container
  long i_erase(const_reference v, const key_type& k)   {
    value_type p = value_type(m_cont.erase(traits::hash(k), v));
    if ( p )    {
      if ( p->parent() == this )  {
        p->setParent(0);
      }
    }
    return traits::release(p) <= 0 ? (long) Containers::OBJ_ERASED
                                   : (long) Containers::OBJ_DELETED;
  }

  /// Internal functor for insertion of objects
  struct _InsertRelease {
    KeyedContainer<DATATYPE,MAPPING>* m_obj;
    _InsertRelease(KeyedContainer<DATATYPE,MAPPING>* p) : m_obj(p) {}
    void operator()(value_type p) {
      m_obj->insert(p);
      traits::release(p);
    }
  };

  /// Internal functor for insertion of objects
  struct _RemoveRelease {
    ObjectContainerBase* m_obj;
    _RemoveRelease(ObjectContainerBase* p) : m_obj(p) {}
    void operator()(value_type p) {
      const ObjectContainerBase* par = p->parent();
      if ( par == m_obj )  {
        p->setParent(0);
      }
      traits::release(p);
    }
  };
  //@}

public:
  /**@name Constructors/Destructors
  */
  //@{
  /// Standard Constructor
  KeyedContainer(void)
  {
    // avoid problems with strict-aliasing rules
    seq_type** rptr = &m_random;
    seq_type*  sptr = &m_sequential;
    m_cont.setup((void*)sptr,(void**)rptr);
  }
  /// Destructor
  virtual ~KeyedContainer();
  //@}

  /**@name DataObject virtual function overloads.
   *  The implementation of these methods is required by the DataObject
   *  base class and determines the persistent run-time-type information.
   */
  //@{
  /// Retrieve class ID
  virtual const CLID& clID() const      {              return this->classID(); }
  /// Retrieve class ID
  static const CLID& classID()          {
    static CLID clid = contained_type::classID() + container_type::classID();
    return clid;
  }
  //@}

  /**@name NOT FOR GENERAL USE ObjectContainerBase function overloads.
   *
   *  The implementation of these methods ensure the behaviour
   *  of the class as a type of class ObjectContainerBase. This
   *  base class and its behaviour are only used by "generic"
   *  object handlers. These classes collaborate with several
   *  classes such as the
   *
   *    - SmartRef classes.
   *    - Generic converters.
   *    - Interfaces for interactivity (e.g. Python)
   *
   *  For this reason, the entry points in this section are reserved
   *  for "generic" object handling and should NOT be used in public.
   */
  //@{
  /// ObjectContainerBase overload: Number of objects in the container
  virtual size_type numberOfObjects() const   {  return m_sequential.size();       }
  /** ObjectContainerBase overload: Add an object to the container.
   *  Plese see the documentation of the member function
   *
   *  const key_type& insert(DATATYPE* pObject)
   *
   *  for further details.
   *
   *  @param   pObject   Pointer to the object to be inserted into the
   *                     container.
   *  @return            long integer representation of the key value.
   */
  virtual long add(ContainedObject* pObject);

  /** ObjectContainerBase overload: Remove an object from the container.
   *  Because this function is also called from the destructor of
   *  The ContainedObject class, it is no longer possible to deduce
   *  the key from the object itself. It is hence necessary to relay
   *  on the **NON-EXISTENCE** of virtual inheritance, ie.
   *  (void*)pObject = (void*)(contained_object).
   *  If the virtual object table is still intact, the normal erase
   *  is called.
   *
   *  @param   pObject   Pointer to the object to be removed from the
   *                     container.
   */
  virtual long remove(ContainedObject* pObject);

  /** ObjectContainerBase overload: Retrieve the object by reference
   *  given the long integer representation of the object's key.
   */
  virtual ContainedObject* containedObject(long key_value) const  {
    return i_object( traits::makeKey( key_value ) );
  }
  /** ObjectContainerBase overload: Retrieve the full long integer
   *  representation of the object's key from the object base class pointer.
   */
  virtual long index(const ContainedObject* p) const;
  /** Retrieve the full content of the object container.
   *  @param   v          Vector of contained objects, which will host
   *                      all objects contained in this container.
   *  @return             Number of objects returned in v.
   */
  virtual size_type containedObjects(std::vector<ContainedObject*>& v) const;
  //@}

  /**@name Container related implementation.
   *  These methods allow to manipulate the container as a whole and to
   *  retrieve information about the internal behaviour of the container.
   */
  //@{
  /// Number of objects in the container
  size_type size() const                {      return m_sequential.size();    }
  /// For consistency with STL: check if container is empty
  bool empty() const                    {      return m_sequential.empty();   }
  /// Reserve place for "value" objects in the container.
  void reserve(size_type value)         {      m_cont.reserve(value);          }
  /// Clear the entire content and erase the objects from the container
  void clear()                          {      erase(begin(), end());          }
  /** Retrieve the full content of the object container by reference.
   *  Returned is the random access container if in sequntial direct
   *  access mode. Otherwise the sequential access container is returned
   *  @return             Reference to sequencal access container.
   */
  virtual const std::vector<const ContainedObject*>* containedObjects() const;
  /** Reconfigure direct access to elements (Needed by POOL data loading)
   *  This function reuses the "update" callback of the generic DataObject
   *  base class.
   */
  virtual StatusCode update();
  //@}

  /**@name Sequential array access to objects using iterators.
   *
   *  Sequential object access using iterators is much faster then object
   *  access by key. In case all objects of the container should be
   *  addressed, use iterators rather than direct object access.
   *
   * - If the container is accessed through the iterators defined below,
   *   the elements may be sorted according to the user needs.
   * - The container can be accesses in both const and non-const mode.
   * - Iterations are supported in both directions: From the beginning to
   *   the end and the reverse.
   */
  //@{
  /// Retrieve start iterator
  iterator begin()                      {      return m_sequential.begin();   }
  /// Retrieve start const iterator
  const_iterator begin()  const         {      return m_sequential.begin();   }
  /// Retrieve terminating iterator
  iterator end()                        {      return m_sequential.end();     }
  /// Retrieve terminating const iterator
  const_iterator end()  const           {      return m_sequential.end();     }
  /// reverse_iterator returns the beginning of the reversed container
  reverse_iterator rbegin()             {      return m_sequential.rbegin();  }
  /// const reverse_iterator returns the beginning of the reversed container
  const_reverse_iterator rbegin() const {      return m_sequential.rbegin();  }
  /// reverse_iterator pointing to the end of the reversed container
  reverse_iterator rend()               {      return m_sequential.rend();    }
  /// const reverse_iterator pointing to the end of the reversed container
  const_reverse_iterator rend() const   {      return m_sequential.rend();    }
  //@}

  /**@name Random access to objects in the container.
   *       Access to objects is given by Key.
   *       Please note, that random object access is nearly in all cases
   *       significantly slower than sequential access. If all objects
   *       in the contaienr should be addresses sequentially, use iterators
   *       rather than direct access. Direct access should only be used
   *       for selective retrieval of objects.
   */
  //@{
  /** Object access by key.
   *  Access contained objects by key.
   *
   *  @param kval Key of the object to be returned.
   *  @return     Valid reference to the requested object. If the key of the
   *              requested object cannot be found in the container a null
   *              reference is returned.
   */
  value_type object(const key_type& kval) const     {  return i_object(kval);  }

  /** STL algorithms support for object access.
   *  Access contained objects by key using the operator(), which is demanded
   *  by STL algorithms.
   *
   *  @param kval Key of the object to be returned.
   *  @return     Valid reference to the requested object. If the key of the
   *              requested object cannot be found in the container a null
   *              reference is returned.
   */
  value_type operator()(const key_type& kval) const {  return i_object(kval);  }
  //@}

  /**@name Insert/Remove objects from the container.
   *  Objects generally are identified by key. Since keys are stored with
   *  the objects, insertions and removals are possible by key or by
   *  reference.
   */
  //@{
  /** Remove/erase object (identified by key) from the container.
   *
   *  @param   kval   Key to identify the object within the container.
   *  @return         Enumeration value from the Containers namespace:
   *                  - OBJ_NOT_FOUND: The indicated object was not found
   *                                   in the container
   *                  - OBJ_ERASED:    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was not yet deleted,
   *                                   because its reference count was
   *                                   non zero.
   *                  - OBJ_DELETED    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was deleted, because
   *                                   its reference count was zero.
   */
  long erase(const key_type& kval)  { return i_erase(0, kval);  }

  /** Remove/erase object (identified by pointer value) from the container.
   *  This member function removes an object, which is identified by its
   *  reference from the container. No key value is supplied. To identify
   *  the object within the container, the key of the object is used as
   *  it can be retrieved using the KeyedObject::key() method.
   *
   *  @param    val   Reference to object to be removed from the container.
   *  @return         Enumeration value from the Containers namespace:
   *                  - OBJ_NOT_FOUND: The indicated object was not found
   *                                   in the container
   *                  - OBJ_ERASED:    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was not yet deleted,
   *                                   because its reference count was
   *                                   non zero.
   *                  - OBJ_DELETED    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was deleted, because
   *                                   its reference count was zero.
   */
  long erase(const value_type val) {
    return (val) ? i_erase(val, val->key()) : (long) Containers::OBJ_NOT_FOUND;
  }

  /** Remove/erase object (identified by iterator) from the container.
   *  This member function removes an object, which is identified by its
   *  reference from the container. No key value is supplied. To identify
   *  the object within the container, the key of the object is used as
   *  it can be retrieved using the KeyedObject::key() method.
   *
   *  @param    val   Reference to object to be removed from the container.
   *  @return         Enumeration value from the Containers namespace:
   *                  - OBJ_NOT_FOUND: The indicated object was not found
   *                                   in the container
   *                  - OBJ_ERASED:    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was not yet deleted,
   *                                   because its reference count was
   *                                   non zero.
   *                  - OBJ_DELETED    The indicated object was found
   *                                   and removed from the container.
   *                                   The object was deleted, because
   *                                   its reference count was zero.
   */
  long erase(iterator pos)   {                return erase(*pos);              }

  /** Remove/erase objects by iterator range.
   *  This member function removes all objects, which are within
   *  the sequential iterator range [pos_start, pos_stop[.
   *
   *  @param    pos_start   Starting iterator of the range to be removed.
   *  @param    pos_stop    Starting iterator of the range to be removed.
   *  @param    use_temp    Flag to indicate that a temporary arry should be used.
   */
  void erase(iterator pos_start, iterator pos_stop, bool use_temp=false);

  /** Insert entry to the container with a valid key.
   *  This member function inserts an element, which is identified by its
   *  reference to the container. The element will be inserted using the
   *  specified key. If the object is already keyed, the long
   *  representations of the supplied key and the object's key must agree.
   *
   *  The object will not be inserted and an exception will be raised
   *  under the following conditions:
   *    - The supplied key does not agree with the object's key.
   *    - An object with the supplied key is already present in the container.
   *
   *  @param    val   Reference to object to be inserted into the container.
   *                  The object reference may NOT be NULL.
   *  @param   kval   Key to identify the object within the container.
   *  @return         Key, which was used to index the object within the
   *                  container. If the operation is not
   *                  successful, an exception is thrown.
   */
  const key_type& insert(const value_type val, const key_type& kval);

  /** Insert entry to the container with automatic key assignment.
   *  This member function inserts an element, which is identified by its
   *  reference to the container. No key value is supplied. The key
   *  used to insert the object is retrieved from the element itself.
   *  In the event the object already has a key, the assigned key of
   *  the object is used. If no key was assigned to the object,
   *  (i.e. the object's key is equal to the invalid key),
   *  a key is generated according to the number of objects present in
   *  the container.
   *
   *  The object will not be inserted and an exception will be raised
   *  under the following conditions:
   *    - A key was already assigned to the object, but
   *      another object with the same key is already present
   *      in the container.
   *
   *  @param    val   Reference to object to be inserted into the container.
   *  @return         Key, which was used to index the object within the
   *                  container. If the operation is not
   *                  successful, an exception is thrown.
   */
  const key_type& insert(const value_type val);
  //@}
};


/**
  *
  *
  *  Inline code for keyed container class
  *
  */

// Destructor
template <class DATATYPE, class MAPPING> inline
KeyedContainer<DATATYPE, MAPPING>::~KeyedContainer()
{
  erase(begin(), end());
  m_cont.clear();
}

// Configure direct access
template <class DATATYPE, class MAPPING> inline
StatusCode KeyedContainer<DATATYPE, MAPPING>::update()
{
  int count = 0;
  m_cont.clearDirect();
  typename seq_type::iterator i = m_sequential.begin();
  typename seq_type::iterator s = m_sequential.end();
  for ( ; i != s; i++ )  {
    typename seq_type::value_type v = *i;
    if ( v )  {
      if ( !v->hasKey() ) {
        traits::setKey(v, v->key());
        traits::addRef(v);
      }
      long k0 = traits::hash(v->key());
      if(m_cont.insertDirect(this, v, v, k0) == Containers::OBJ_INSERTED)   {
      }
    }
    else  {
      ++count;
    }
  }
  if ( count > 0 )  {
    Containers::cannotInsertToContainer();
  }
  return StatusCode::SUCCESS;
}


// Retrieve the full content of the object container by reference.
template <class DATATYPE, class MAPPING> inline
const std::vector<const ContainedObject*>*
KeyedContainer<DATATYPE, MAPPING>::containedObjects() const  {
  return (const std::vector<const ContainedObject*>*)
    ((0==m_cont.isDirect()) ? m_random : &m_sequential);
}

template <class DATATYPE, class MAPPING> inline
const typename KeyedContainer<DATATYPE, MAPPING>::key_type&
KeyedContainer<DATATYPE, MAPPING>::insert(const value_type val,
                                          const key_type& kval)
{
  if ( val )    {
    long k0 = traits::hash(kval);
    if ( !val->hasKey() || (traits::hash(val->key()) == k0) )    {
      if(m_cont.insert(this,val,val,k0) == Containers::OBJ_INSERTED)   {
        if ( !val->hasKey() ) traits::setKey(val, kval);
        traits::addRef(val);
        return val->key();
      }
    }
  }
  // Cannot insert object...indicate bad object insertion...
  Containers::cannotInsertToContainer();
  return val->key();
}

// Insert object
template <class DATATYPE, class MAPPING> //inline
const typename KeyedContainer<DATATYPE, MAPPING>::key_type&
KeyedContainer<DATATYPE, MAPPING>::insert(const value_type val)
{
  if ( 0 != val )   {
    if ( val->hasKey() )   {
      if (m_cont.insert(this,val,val,traits::hash(val->key()))
          == Containers::OBJ_INSERTED)   {
        traits::addRef(val);
        return val->key();
      }
    }
    long k0;
    if ( m_cont.insert(this, val, val, &k0) == Containers::OBJ_INSERTED )   {
      traits::setKey(val, traits::makeKey(k0));
      traits::addRef(val);
      return val->key();
    }
  }
  // Cannot insert object...indicate bad object insertion...
  Containers::cannotInsertToContainer();
  return val->key();
}

template <class DATATYPE, class MAPPING> inline
long KeyedContainer<DATATYPE, MAPPING>::index(const ContainedObject* p) const
{
  const contained_type* ptr = dynamic_cast<const contained_type*>(p);
  if ( ptr ) return traits::identifier(ptr->key());
  return -1;
}

// Retrieve the full content of the object container.
template <class DATATYPE, class MAPPING> inline
typename KeyedContainer<DATATYPE, MAPPING>::size_type KeyedContainer<DATATYPE, MAPPING>::containedObjects
(std::vector<ContainedObject*>& vec) const
{
  typename seq_type::const_iterator i = m_sequential.begin();
  typename seq_type::const_iterator s = m_sequential.end();
  vec.clear();
  vec.reserve(size());
  for ( ; i != s; i++ )  {
    ContainedObject* p = const_cast<typename seq_type::value_type>(*i);
    vec.push_back(p);
  }
  return vec.size();
}

// ObjectContainerBase overload: Add an object to the container.
template <class DATATYPE, class MAPPING> inline
long KeyedContainer<DATATYPE, MAPPING>::add(ContainedObject* pObject)
{
  return traits::identifier(insert(dynamic_cast<typename seq_type::value_type>(pObject)));
}

// ObjectContainerBase overload: Remove an object from the container.
template <class DATATYPE, class MAPPING> inline
long KeyedContainer<DATATYPE, MAPPING>::remove(ContainedObject* p)
{
  contained_type* p1 = dynamic_cast<contained_type*>(p);
  if ( p1 )    {  // Normal case; object still fully intact
    return this->erase(p1);
  }
  else if ( p )   {
    const ObjectContainerBase* par = p->parent();
    // The following should never occur: object is in a funny state,
    // Because the parent was explicitly set to NULL in the
    // KeyeObject destructor.
    // - It cannot be a KeyedObject:  It would not have a parent
    // - Still the parent is present: We are not in the destructor
    //                                of KeyedObject
    if ( par )  {
      Containers::invalidContainerOperation();
    }
    return m_cont.erase(0, p)==0 ? (long) Containers::OBJ_ERASED
                                 : (long) Containers::OBJ_NOT_FOUND;
  }
  return (long) Containers::OBJ_NOT_FOUND;
}

template <class DATATYPE, class MAPPING> inline
void
KeyedContainer<DATATYPE, MAPPING>::erase(iterator start_pos,
                                         iterator stop_pos,
                                         bool use_tmp)
{
  bool is_start = start_pos == m_sequential.begin();
  bool is_stop  = stop_pos  == m_sequential.end();
  if ( is_start && is_stop )  {
    // Nothing special. Taken care of by Keyed object manager
  }
  else if ( is_start || is_stop || use_tmp )  {
    std::vector<DATATYPE*> tmp(m_sequential.begin(), start_pos);
    tmp.insert(tmp.end(), stop_pos, m_sequential.end());
    std::for_each(tmp.begin(), tmp.end(), traits::addRef);
    this->erase(m_sequential.begin(), m_sequential.end());
    std::for_each(tmp.begin(), tmp.end(), _InsertRelease(this));
    return;
  }
  std::for_each(start_pos, stop_pos, _RemoveRelease(this));
  seq_type *sptr = &m_sequential; // avoid problems with strict-aliasing rules
  std::vector<void*>* v = (std::vector<void*>*)sptr;
  std::vector<void*>::iterator i1 =
    v->begin() + std::distance(m_sequential.begin(), start_pos);
  std::vector<void*>::iterator i2 =
    v->begin() + std::distance(m_sequential.begin(), stop_pos);
  m_cont.erase(i1, i2);
}

#undef FORCE_INLINE
#endif // GAUDIKERNEL_KEYEDCONTAINER_H
