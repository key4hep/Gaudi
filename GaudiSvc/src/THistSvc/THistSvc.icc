#ifndef GAUDISVC_THISTSVC_ICC
#define GAUDISVC_THISTSVC_ICC

#ifndef GAUDIKERNEL_MSGSTREAM_H
 #include "GaudiKernel/MsgStream.h"
#endif

#include "GaudiKernel/System.h"

#include <string>
#include <map>

#include "TObject.h"
#include "TFile.h"

template <typename T>
StatusCode THistSvc::regHist_i(T* hist, const std::string& id, bool shared, 
                               THistID*& phid) {

  GlobalDirectoryRestore restore(m_svcMut);
  phid = nullptr;

  debug() << "regHist_i obj: " << hist << "  id: " << id << "  s: " << shared
          << endmsg;

  std::string idr(id);
  removeDoubleSlash( idr );

  if (idr.find("/") == idr.length()) {
    error() << "Badly formed identifier \"" << idr << "\": "
        << "Must not end with a /" << endmsg;
    return StatusCode::FAILURE;
  }


  TFile *f = nullptr;
  std::string stream, name;
  if (!findStream(idr, stream, name, f)) {
    m_log << MSG::ERROR << "Could not register id: \"" << idr << "\""
          << endmsg;
    return StatusCode::FAILURE;
  }

  std::string uid = "/" + stream + "/" + name;

  uidMap_t::iterator uitr = m_uids.find( uid );
  bool exists(false);
  // size_t index {0};
  if (uitr != m_uids.end() ) {
    exists = true;
    TObject* t1 = uitr->second->at(0).obj;
    if ( hist->Compare( t1 ) != 0 ) {
      error() << "previously registered object with identifier \"" << uid
              << "\" does not compare to this one" << endmsg;
      return StatusCode::FAILURE;
    } else {
      // index = uitr->second->size();
      debug() << "previously registered id \"" << uid << "\": num "
              << uitr->second->size() << endmsg;
    }
  }

  bool temp = false;
  if ( !f ) {
    temp = true;
    if (msgLevel(MSG::DEBUG))
      debug() << "Historgram with id \"" << idr << "\" is temporary"
	    << endmsg;
  }


  TObject *to = nullptr;
  THistID hid;

  // check to see if this hist is to be read in;
  if (!temp && m_files.find(stream)->second.second == READ) {

    if (hist != 0) {
      warning() <<  "Registering id: \"" << idr
	    << "\" with non zero pointer!" << endmsg;
    }

    if (readHist_i(idr,hist).isFailure()) {
      error() <<  "Unable to read in hist" << endmsg;
      return StatusCode::FAILURE;
    }
    to = dynamic_cast<TObject*>(hist);
    hid = THistID(uid,temp,to,f,m_files.find(stream)->second.second);

  } else if (hist == 0) {
    error() << "Unable to read in hist with id: \""
	  << idr << "\"" << endmsg;
    return StatusCode::FAILURE;

  } else {

    to = dynamic_cast<TObject*>(hist);
    if (to == 0) {
      error() << "Could not dcast to TObject. id: \"" << idr
	    << "\"" << endmsg;
      return StatusCode::FAILURE;
    }

    auto oitr = m_tobjs.find(to);
    if (oitr != m_tobjs.end()) {
      m_log << MSG::ERROR << "already registered id: \"" << idr
	    << "\" with identifier \"" 
            << oitr->second.first->at(oitr->second.second).id << "\"" << endmsg;
      return StatusCode::FAILURE;
    }

    hid = THistID(uid,temp,to,f,m_files.find(stream)->second.second);
    hid.shared = shared;
    TDirectory* dir = changeDir(hid);

    if ( dynamic_cast<TTree*>(hist) ) {
      dynamic_cast<TTree*>(hist)->SetDirectory(dir);
    } else if ( dynamic_cast<TH1*>(hist) ) {
      dynamic_cast<TH1*>(hist)->SetDirectory(dir);
    } else if ( dynamic_cast<TGraph*>(hist) ) {
      dir->Append(hist);
    } else {
      error() << "id: \"" << idr
	    << "\" is not a TH, TTree, or TGraph. Attaching it to current dir."
	    << endmsg;
      dir->Append(hist);
    }

  }

  std::string fname;
  if ( !f ) {
    fname = "none";
  } else {
    fname = f->GetName();
  }

  debug() << "Registering" 
          << (shared ? " shared " : " ")
          << System::typeinfoName(typeid(*hist))
	  << " title: \"" << hist->GetTitle()
	  << "\"  id: \"" << uid << "\"  dir: "
    //      << hist->GetDirectory()->GetPath() << "  "
	  << changeDir(hid)->GetPath()
	  << "  file: " << fname
	  << endmsg;


  // create a mutex for all shared histograms
  if (shared) {
    hid.mutex = new histMut_t;
  }

  if (exists) {
    vhid_t* vi = uitr->second;
    vi->push_back(hid);
    phid = &(vi->back());

    m_tobjs.emplace(to, std::pair<vhid_t*,size_t>(vi, vi->size()-1) );

    // debug() << "add THistID*: " << phid << " TObject*: " << to 
    //         << " vec<TID>*: " << vi << "  id: " << *phid
    //         << endmsg;

    // uitr->second->push_back(hid);
    // phid = &(uitr->second->back());
    // m_tobjs.emplace(to, & (uitr->second->back()) );
  } else {
    vhid_t* vi = new vhid_t { hid };
    m_hlist.emplace( m_hlist.end(), vi );

    //    vhid_t* vi = &*(m_hlist.emplace(m_hlist.end(), vhid_t { hid } ) );
    phid = &(vi->back());
    m_uids.emplace(uid, vi);
    m_ids.emplace(name,vi);

    // debug() << "add new THistID: " << phid << " TObject: " << to << "  id: " << *phid
    //         << endmsg;

    m_tobjs.emplace(to, std::pair<vhid_t*, size_t>(vi,0) );
  }

  debug() << "regHist_i  THistID: " << hid << endmsg;


  // m_idsX.emplace(name, hid);
  // m_uidsX[uid] = hid;
  // m_tobjs[to] = hid;

  // histMap::iterator hitr = m_hmap.find(uid);
  // if (hitr != m_hmap.end()) {
  //   hitr->second.push_back(hid);
  // } else {
  //   m_hmap[uid] = std::vector<THistID>{hid};
  // }

  return StatusCode::SUCCESS;

}

//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//

template <typename T>
StatusCode 
THistSvc::getHist_i(const std::string& id, T*& hist, const size_t& ind, bool quiet) const {
  // id starts with "/": unique

  GlobalDirectoryRestore restore(m_svcMut);

  const THistID* hid;
  size_t num = findHistID(id,hid,ind);
  if (num == 0) {
    // no matches found
    if (!quiet) {
      error() << "could not locate Hist with id \"" << id << "\"" << endmsg;
    }
    hist = nullptr;
    return StatusCode::FAILURE;
  } else if (num > 1) {
    if (!quiet) {
      // return failure if trying to GET a single hist
      error() << "Multiple matches with id \"" << id << "\"."
              << " Further specifications required."
              << endmsg;
      hist = nullptr;
      return StatusCode::FAILURE;
    } else {
      // return a SUCCESS if just INQUIRING
      info() << "Found multiple matches with id \"" << id
             << "\"" << endmsg;
      hist = nullptr;
      return StatusCode::SUCCESS;
    }
  } else {
    if (!quiet) {
      hist = dynamic_cast<T*>(hid->obj);
      if ( !hist ) {
        error() << "dcast failed, Hist id: \"" << id << "\""
                << endmsg;
        return StatusCode::FAILURE;
      }

      verbose() << "found unique Hist title: \"" 
                << hist->GetTitle()
                << "\"  id: \"" << id << "\"" << endmsg;


    } else {
      verbose() << "found unique Hist id: \"" << id
                << "\" type: \"" << hid->obj->IsA()->GetName() << "\""
                << endmsg;
    }

    return StatusCode::SUCCESS;

  }

  // std::string idr(id);
  // removeDoubleSlash( idr );

  // if (idr.find("/") == 0) {
  //   auto itr = m_uidsX.find(id);
  //   if (itr == m_uidsX.end()) {
  //     if (!quiet) {
  //       m_log << MSG::ERROR << "Could not locate Hist with id \"" << idr << "\""
  //             << endmsg;
  //     }
  //     hist = nullptr;
  //     return StatusCode::FAILURE;
  //   }
  //   THistID hid = itr->second;
  //   if (!quiet) {
  //     hist = dynamic_cast<T*>(hid.obj);
  //     if ( !hist ) {
  //       m_log << MSG::ERROR << "dcast failed, Hist id: \"" << idr << "\"" 
  //             << endmsg;
  //       return StatusCode::FAILURE;
  //     }
  //     if (m_log.level() <= MSG::VERBOSE) {
  //       m_log << MSG::VERBOSE << "found unique Hist title: \"" 
  //             << hist->GetTitle()
  //             << "\"  id: \"" << idr << "\"" << endmsg;
  //     }
  //   } else {
  //     if (m_log.level() <= MSG::VERBOSE) {
  //       m_log << MSG::VERBOSE << "found unique Hist id: \"" << idr 
  //             << "\" type: \"" << hid.obj->IsA()->GetName() << "\""
  //             << endmsg;
  //     }
  //   }
  //   return StatusCode::SUCCESS;
  //   // not necessarily unique
  // } else {
  //     auto mitr = m_idsX.equal_range(idr);
  //   if (mitr.first == mitr.second) {
  //     m_log << MSG::ERROR << "Could not locate Hist with id \"" << idr << "\""
  //           << endmsg;
  //     hist = nullptr;
  //     return StatusCode::FAILURE;
  //   } else {
  //     if (distance(mitr.first,mitr.second) == 1) {
  //       THistID hid = mitr.first->second;
  //       if (!quiet) {
  //         hist = dynamic_cast<T*>(hid.obj);
  //         if (hist == 0) {
  //           m_log << MSG::ERROR << "dcast failed" << endmsg;
  //           return StatusCode::FAILURE;
  //         }
  //         if (m_log.level() <= MSG::VERBOSE) {
  //           m_log << MSG::VERBOSE << "found Hist title: \"" << hist->GetTitle()
  //       	  << "\"  id: \"" << idr << "\"" << endmsg;
  //         }
  //       } else {
  //         if (m_log.level() <= MSG::VERBOSE) {
  //           m_log << MSG::VERBOSE << "found Hist id: \"" << idr << "\" type: \""
  //       	  << hid.obj->IsA()->GetName() << "\""
  //       	  << endmsg;
  //         }
  //       }
  //       return StatusCode::SUCCESS;
  //     } else {
  //       if (!quiet) {
  //         // return failure if trying to GET a single hist
  //         m_log << MSG::ERROR << "Multiple matches with id \"" << idr << "\"."
  //       	<< " Further specifications required."
  //       	<< endmsg;
  //         hist = nullptr;
  //         return StatusCode::FAILURE;
  //       } else {
  //         // return a SUCCESS if just INQUIRING
  //         m_log << MSG::INFO << "Found multiple matches with id \"" << idr 
  //             << "\"" << endmsg;
  //         hist = nullptr;
  //         return StatusCode::SUCCESS;
  //       }
  //     }
  //   }
  // }

}

//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//

template <typename T>
StatusCode
THistSvc::readHist_i(const std::string& id, T*& hist) const {

  GlobalDirectoryRestore restore(m_svcMut);

  std::string idr(id);
  removeDoubleSlash( idr );

  std::string stream, rem, dir, fdir, bdir, fdir2;
  TFile *file;

  if (!findStream(idr, stream, rem, file) ) {
    return StatusCode::FAILURE;
  }

  if ( !file ) {
    error() << "no associated file found" << endmsg;
    return StatusCode::FAILURE;
  }

  file->cd("/");

  fdir = idr;
  bdir = dirname(fdir);
  fdir2 = fdir;
  while ( (dir=dirname(fdir)) != "" ) {
    if (! gDirectory->GetKey(dir.c_str())) {
      error() << "Directory \"" << fdir2 << "\" doesnt exist in "
	    << file->GetName() << endmsg;
      return StatusCode::FAILURE;
    }
    gDirectory->cd(dir.c_str());
  }

  TObject *to=nullptr;
  gDirectory->GetObject(fdir.c_str(), to);

  if ( !to ) {
    error() << "Could not get obj \"" << fdir << "\" in "
	  << gDirectory->GetPath() << endmsg;
    return StatusCode::FAILURE;
  }



  hist = dynamic_cast<T*>(to);
  if ( !hist ) {
    error() << "Could not convert \"" << idr << "\" to a "
	  << System::typeinfoName(typeid(*hist)) << " as is a "
	  << to->IsA()->GetName()
	  << endmsg;
    return StatusCode::FAILURE;
  }


  if (msgLevel(MSG::DEBUG)) {
    debug() << "Read in " << hist->IsA()->GetName() << "  \""
	  << hist->GetName() << "\" from file "
	  << file->GetName() << endmsg;
    hist->Print();
  }

  return StatusCode::SUCCESS;

}


//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//

template <typename T>
StatusCode 
THistSvc::regSharedObj_i(const std::string& id, std::unique_ptr<T>& hist,
                          LockedHandle<T>& lh) {


  const THistID* hid;
  if (findHistID(id,hid) == 0) {
    T* phist = hist.get();
    THistID* phid;
    if (regHist_i(hist.release(),id,true,phid).isSuccess()) {
      lh.set(phist,phid->mutex);

      return StatusCode::SUCCESS;

    } else {
      error() << "regSharedHist: unable to register shared hist with id \"" 
              << id << "\""
              << endmsg;
      lh.set(nullptr,nullptr);
      return StatusCode::FAILURE;
    }
  } else {
    
    if (! hid->shared ) {
      error() << "regSharedHist: previously register Hist with id \"" << id
              << "\" was not marked shared"
              << endmsg;
      lh.set(nullptr, nullptr);
      return StatusCode::FAILURE;
    }

    if (hist->Compare( hid->obj ) != 0) {
      error() << "regSharedHist: Histogram " << id << " does not compare with " 
              << hid
              << endmsg;
      lh.set(nullptr,nullptr);
      return StatusCode::FAILURE;
    } else {
      T* phist = dynamic_cast<T*> ( hid->obj );
      if (phist == 0) {
        error() << "regSharedHist: unable to dcast retrieved shared hist \""
                << id << "\" of type "
                << hid->obj->IsA()->GetName() << " to requested type " 
                << phist->IsA()->GetName()
                << endmsg;
        lh.set(nullptr, nullptr);
        return StatusCode::FAILURE;
      } else {
        lh.set(phist, hid->mutex);
        delete hist.release();
        return StatusCode::SUCCESS;
      }
    }
  }

}


//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//

template <typename T>
StatusCode 
THistSvc::getSharedObj_i(const std::string& name, 
                         LockedHandle<T>& hist) const {


  GlobalDirectoryRestore restore(m_svcMut);

  const THistID* hid;
  size_t i = findHistID(name, hid);

  if (i == 1) {

    if ( !hid->shared ) {
      error() << "getSharedHist: found Hist with id \"" << name
              << "\", but it's not marked as shared"
              << endmsg;
      return StatusCode::FAILURE;
    }
    T* h1 = dynamic_cast< T*> ( hid->obj );
    hist = LockedHandle<T> (h1, hid->mutex);

    debug() << "getSharedHist: found THistID: " << *hid << endmsg;

    return StatusCode::SUCCESS;
  } else if (i == 0) {
    error() << "no histograms matching id \"" << name << "\" found"
            << endmsg;
    return StatusCode::FAILURE;
  } else {
    info() << "multiple matches for id \"" << name << "\" found [" << i 
           << "], probably from different streams"
           << endmsg;
    return StatusCode::FAILURE;
  }


}

#endif
