2010-05-31 08:47:06
Features to add:
 * "Map" special property value (as for Vector)
 * implementation of class aliases (e.g. EvtDataSvc -> EventDataSvc)
   Probably it is enough to just subclass the actual class with the new name
 * support for namespaces (how?)
 * tools: may be with a property 'parent' that reflects itself in the name used
   in Configurable._instances (it might not be needed to touch the actual name),
   then the change of name of the parent must update the _instances map for the
   private tools (do we want the tools to be accessible from the parent?)
 * validators for components: a string property is often a place-holder for a
   component type/name. The property should accept strings or instances and
   validate (at least) the type of component (Algorithm, AlgTool, Service) and
   possibly the requested interfaces.
   When requested, the property should instantiate the proper configurable instance
   and return it (implement the same semantic as Vector and Map?)
 * we need a way of selecting the right validator from the C++.
   One possibility is to pass to "genconf" the module with custom validators,
   which must contain a map "C++ typeinfo" -> "validator instance" (or update the
   main map in the main modules)
 * Database of configurables.
   It must be a text database, instead of a module, a la rootmap:
     C++ class -> Python configurable class
   It could be generated from the Python modules in post-process step (like the
   rootmap or the configurable user).
   (remember to treat correctly the zipped python directories)

2010-05-31 10:46:50
Added base classes for Service, Algorithm and AlgTool.

2010-05-31 12:06:52
Instead of the selection of the validator, we need to select the property according
to the C++ typeinfo.

2010-05-31 14:23:15
Since the instantiation of an object with a name already used is not possible, an
easy way of replacing the existing instance with an instance of the new type is
needed. Or better, we need a way to copy all the set properties from one
instance to another and the function to get the existing instance.

2010-05-31 16:14:10
Warning: ctypes-based floating point number validator not yet implemented.

2010-10-28 15:30:36
A simple extension to the Property base class allow genconf to print the C++ type of
the Property itself.
The template arguments of the property class can be used as template argument of
a small helper function to produce an effective validator (using Boost Python).
E.g.:
// in the C++ python module
BOOST_PYTHON_MODULE(validators)
{
  using namespace boost::python;
  def("SimpleProperty<int,BoundedVerifier<int> >",
      check<int,BoundedVerifier<int> >);
}
# in Python
Property(name = "MyInt",
         validator = findValidator('SimpleProperty<int,BoundedVerifier<int> >'),
         default = 123,
         doc = "An integer property")

An open question is how to effectively avoid duplications. For small projects it
may be OK to have one validation module per component library, but we should not
need more than a handful of validators modules (we have only a limited set of
properties).

2010-10-28 18:34:20
It has been sort of easy to modify genconf and GaudiPolicy to allow for the creation
of the binary python validators (still with duplicates).
I also added the generation of a python module for the configurable classes. The
description of the components is done with a dictionary, passed to a generic function
that translates the descriptions in classes in the namespace of the module (it
should reduce the memory footprint of the components modules without funny deletes
of functions).
The database of configurables and of validators still has to be added.

2010-10-28 19:25:32
I cannot compile the validators for GaudiExamples, but I managed to get the components
module right (at least a preliminary version).
The requirements in GaudiPolicy may need tuning to correctly re-generate the
configurables.
I should also improve the documentation of the properties adding type and default
value.

2010-10-29 08:23:21
One interesting possibility for the configurables database is to use a BerkleyDB.
It will efficiently handle automatically merge and locking (no need for 2 steps).
The problem is that it cannot be stored in a zip file, so either we use the binary
Python modules directory or PATH or LD_LIBRARY_PATH. Alternatively, we can add yet
one more environment variable.

2010-10-29 15:54:47
Several improvements in the creation, documentation of the properties.
Tried to run the tests, but need to be fixed.
GaudiExamples compiles and mainly works (Handles must be tested).

2010-10-29 20:01:11
To play with BDM, probably it is best to start with the validators. For the configurables
themselves I may directly store their description directly in a DB and be done
with it.

2010-10-31 14:52:40
The tricky part of using a db of the validators is to build the validators module
only if needed.
Possible solutions are:
1) collect all the validators in a single module for the whole
project (similar to the "merged" confDb or to the python.zip (build delayed to the
container?).
2) put the code to build the validator module in the genconfig fragment, so that
it can be triggered conditionally by the presence of the .cpp file.

2010-11-01 19:10:51
This is an interesting idea about how to deal with the validators database.
We can use a single validators module per projects (option '1' above), but we do
not need a database, because the database of configurables is enough.
This is how we can do it:
 - genconf just updates the database with the configurables description
   (it has to remove everything for the current library and re-add it)
 - in a second step (triggered like the zipping of python modules) we can go
   through the database of configurables to generate the python binary module
   with the validators
In this scheme there is no need for an actual python module with the configurables,
but the "Configurables" module can just look-up in the database the descriptions
and create the actual classes on demand.
