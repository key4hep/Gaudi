// -*- C++ -*-
// AID-GENERATED
// =========================================================================
// This class was generated by AID - Abstract Interface Definition
// DO NOT MODIFY, but use the org.freehep.aid.Aid utility to regenerate it.
// =========================================================================
#pragma once

//  This file is part of the AIDA library
//  Copyright (C) 2002 by the AIDA team.  All rights reserved.
//  This library is free software and under the terms of the
//  GNU Library General Public License described in the LGPL.txt

#include <AIDA/IAxis.h>

#include <TAxis.h>

namespace Gaudi {

  /**
   * An IAxis represents a binned histogram axis. A 1D Histogram would have
   * one Axis representing the X axis, while a 2D Histogram would have two
   * axes representing the X and Y Axis.
   *
   * @author The AIDA team (http://aida.freehep.org/)
   *
   */
  class Axis : public AIDA::IAxis {
  public:
    static int toRootIndex( int index, int nbins ) {
      if ( index == AIDA::IAxis::OVERFLOW_BIN ) return nbins + 1;
      if ( index == AIDA::IAxis::UNDERFLOW_BIN ) return 0;
      return index + 1;
    }

    static int toAidaIndex( int index, int bins ) {
      if ( index == bins + 1 ) return AIDA::IAxis::OVERFLOW_BIN;
      if ( index == 0 ) return AIDA::IAxis::UNDERFLOW_BIN;
      return index - 1;
    }

    /**
     * Convert a AIDA bin number on the axis to the ROOT bin number.
     * @param index TheAIDA bin number
     * @return      The corresponding ROOT bin number.
     *
     */
    int rIndex( int index ) const { return toRootIndex( index, bins() ); }

    /**
     * Convert a ROOT bin number on the axis to the AIDA bin number.
     * @param index The ROOT bin number: 1 to bins() for the in-range bins or bins()+1 for OVERFLOW or 0 for UNDERFLOW.
     * @return      The corresponding AIDA bin number.
     *
     */
    int aIndex( int index ) const { return toAidaIndex( index, bins() ); }

  public:
    Axis() = default;
    explicit Axis( TAxis* itaxi ) : taxis_( itaxi ) {}

    void initialize( TAxis* itaxi, bool ) { taxis_ = itaxi; }

    /**
     * Check if the IAxis has fixed binning, i.e. if all the bins have the same width.
     * @return <code>true</code> if the binning is fixed, <code>false</code> otherwise.
     *
     */
    bool isFixedBinning() const override { return 0 == taxis_ ? true : !taxis_->IsVariableBinSize(); }

    /**
     * Get the lower edge of the IAxis.
     * @return The IAxis's lower edge.
     *
     */
    double lowerEdge() const override { return taxis().GetXmin(); }

    /**
     * Get the upper edge of the IAxis.
     * @return The IAxis's upper edge.
     *
     */
    double upperEdge() const override { return taxis().GetXmax(); }

    /**
     * The number of bins (excluding underflow and overflow) on the IAxis.
     * @return The IAxis's number of bins.
     *
     */
    int bins() const override { return taxis().GetNbins(); }

    /**
     * Get the lower edge of the specified bin.
     * @param index The bin number: 0 to bins()-1 for the in-range bins or OVERFLOW or UNDERFLOW.
     * @return      The lower edge of the corresponding bin; for the underflow bin this is
     * <tt>Double.NEGATIVE_INFINITY</tt>.
     *
     */
    double binLowerEdge( int index ) const override { return taxis().GetBinLowEdge( rIndex( index ) ); }
    /**
     * Get the upper edge of the specified bin.
     * @param index The bin number: 0 to bins()-1 for the in-range bins or OVERFLOW or UNDERFLOW.
     * @return      The upper edge of the corresponding bin; for the overflow bin this is
     * <tt>Double.POSITIVE_INFINITY</tt>.
     *
     */
    double binUpperEdge( int index ) const override { return taxis().GetBinUpEdge( rIndex( index ) ); }

    /**
     * Get the width of the specified bin.
     * @param index The bin number: 0 to bins()-1) for the in-range bins or OVERFLOW or UNDERFLOW.
     * @return      The width of the corresponding bin.
     *
     */
    double binWidth( int index ) const override { return taxis().GetBinWidth( rIndex( index ) ); }

    /**
     * Convert a coordinate on the axis to a bin number.
     * If the coordinate is less than the lowerEdge UNDERFLOW is returned; if the coordinate is greater or
     * equal to the upperEdge OVERFLOW is returned.
     * @param coord The coordinate to be converted.
     * @return      The corresponding bin number.
     *
     */

    int coordToIndex( double coord ) const override { return aIndex( taxis().FindBin( coord ) ); }

    /**
     *
     */
    TAxis& taxis() const { return *me().taxis_; }

  private:
    Axis& me() const { return const_cast<Axis&>( *this ); }

    TAxis* taxis_ = nullptr;

  }; // class

} // namespace Gaudi
